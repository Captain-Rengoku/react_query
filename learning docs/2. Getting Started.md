# React Query - Getting Started Setup

## 1. Install Dependencies

Go to react query docs for installation
-- <https://tanstack.com/query/latest/docs/framework/react/installation>

```bash
# Install React Query
npm install @tanstack/react-query

# Optional: React Query Devtools
npm install @tanstack/react-query-devtools
```

also install react-router for routing in React

```bash
npm install react-router
```

## 2. Set Up Query Client

Create a `QueryClient` and wrap your app with `QueryClientProvider` in `main.jsx`.

```js
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

// Create a client
const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </React.StrictMode>
);
```

## 3. Create a Fetcher Function

Define a function that fetches data from your API. You can use `fetch` or `axios`.

```js
// api/posts.js
export const fetchPosts = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/posts");
  if (!response.ok) {
    throw new Error("Network response was not ok");
  }
  return response.json();
};
```

```js
// api/posts.js
import axios from "axios";
export const fetchPosts = async () => {
  try {
    const response = await axios.get("https://jsonplaceholder.typicode.com/posts");
    return response.data;
  } catch (error) {
    throw new Error(error.response?.statusText || "Network request failed");
  }
};
```

## 4. Use React Query in a Component

Use `useQuery` to fetch data and handle loading, error, and success states automatically.

```js
import { useQuery } from "@tanstack/react-query";
import { fetchPosts } from "./api/posts";

export default function PostsList() {
  const { data, isLoading, isError, error } = useQuery({
    // the path becomes the queryKey here,
      // /posts --> ["posts"]
      // /posts/1 --> ["posts", 1]
      // /posts/2 --> ["posts", 2]
      // or for dynamic route
      // /posts/:id --> ["posts", post.id]
      // /posts/:id/comments --> ["posts", post.id, "comments"]
    queryKey: ["posts"],
    // the queryFn is a Callback Function that returns a promise
    queryFn: fetchPosts,
  });

  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>
          <h3>{post.title}</h3>
          <p>{post.body}</p>
        </li>
      ))}
    </ul>
  );
}
```

## 5. Key Concepts

- **queryKey** → Unique key for caching and refetching.
- **queryFn** → Function returning a promise (fetcher).
- **Automatic caching** → Data is cached and updated automatically.
- **Stale time & refetch** → Configurable to control updates.
- **Devtools** → Visualize query cache and state in the browser.
